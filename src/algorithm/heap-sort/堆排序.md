## 堆排序（以下都采取自上向下的堆调整方式）

### 概念理解

1. 数组是可以对应成完全二叉树的。
2. 父节点(p)和子节点(i)的索引计算公式是：
   - 推导过程：![父子节点公式](./%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91_%E7%88%B6%E5%AD%90%E7%B4%A2%E5%BC%95%E6%8E%A8%E5%AF%BC.jpg)
   - 父节点和左子节点：p = i \* 2 + 1
   - 父节点和右子节点：p = i \* 2 + 2
3. 最后一个非叶子节点，也就是最后一个有子节点的父节点，它的索引是：Math.floor(数组长度/2 - 1)
   - 推导过程：
     - 最后一个节点的父节点就是最后一个非叶子节点。
     - 假定 len = 数组长度，len - 1 是最后一个节点设置成 i，它的父节点是 p ,也就是父子节点索引计算公式：
     - 由于不知道最后一个节点是左子节点还是有子节点，所以有两个算法：p = i \* 2 + 1 或 p = i \* 2 + 2
     - i = (p - 1)/2 或 i = (p -2)/2，也就是 ==>
     - i = p/2 - 1/2 或 i = p/2 - 1, 虽然不知道最后一个节点是左子节点还是有子节点，但是确定 i 是整数，那么都先减去 1/2，然后向下取整就能抹平 1/2 的差距。也就是
     - i = Math.floor(p /2 - 1/2); 也就是
     - i = Math.floor(((len - 1)/2 - 1/2))
     - i = Math.floor(len/2 - 1)
4. 能排序的方法：每次堆调整能获得最大值(把单元堆的最大值放在父节点上)，这样遍历完一遍之后，最大值就在最上面，对应的索引是 0.也就是第一个，第一次遍历时把最大值放在最后一个值交换，然后最后一个值不参与堆调整，从倒数第二个值的开始堆调整，就保存下来最大的值了，这样倒序遍历进行堆调整。保存下来的值递增，需要遍历的值递减
5. 能排序的方法 2：遍历之前就必须是最大堆。这样才能保证第一个是最大值。

### 步骤

1. 最大堆构建

   - 取得最后一个非子叶节点，也就是最后一个父节点，改节点作为父节点来，也作为遍历的起始点，每个节点做一次向下筛选。
   - 时间复杂度是 O(n)，原推导式是 n - log(n+1)，采取自上向下的建堆方法。
     - 假设数组能构建出来完全二叉树，一共是 h 层。采取的是自上向下的建堆方法。
     - 每个节点向下筛选的次数是有规律的，第 k 层(k 从 0 开始)，它可以向下筛选的最大次数是 h-k。因为它是作为父节点和子节点比较的，交换位置的子节点继续作为父节点和子节点比较，所以第 h 层能比较 0 次，h-1 层能比较 1 次，h-2 层能比较 2 次，以此类推，第 0 层能比较 h 次。
     - 同一层的节点能比较的次数一样，第 k 层的节点个数是 2^k，那么第 k 层能比较的次数就是`第k层单个节点能比较的次数`\*`第k层所有节点个数`，即(h-k)\*2^k
     - 层高 h 和总数 n 的关系满足：n = 2^(h+1) - 1，即 h = log(n + 1) - 1。
     - 接下来就是求和公式的推导，图中的 h 是从 0 开始的，n 是从 1 开始的，推导过程：![构建最大堆的时间复杂度](./%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg)

2. ## 排序

   - 每次 index = 0 的值和 index = last 值交换，然后将剩下的数组倒序进行单元堆调整，能把最大值调整到 index = 0 的位置，剩下的数据调整，这样每次进行堆调整的数组是递减的。同时也保证保留下来的值是最大的。
   - 遍历的过程，每次都从最顶部开始执行向下筛选
   - 堆(最大堆)调整的方法是：父节点与`两个子节点中的最大值`比较，比如父节点小于`两个子节点中的最大值`，那么将`两个子节点中的最大值`和父节点交换位置。
   - 交换时，将交换的节点作为父节点继续进行堆调整
   - 堆调整的时间复杂度是 log(n)

3. 重复 2
   - 时间复杂度： n(log n)。精确公式是 log(n) + log(n-1) + log(n-2) + ...... + log(1)
   - 获取上限推导：log(1) + log(2) + ... + log(n) <= log(n) + log(n) + ... + log(n) = n\*log(n)
   - 获取下限推导：`log(1) + ... + log(n/2) + ... + log(n) >= log(n/2) + ... + log(n) = log(n/2) + log(n/2+1) + ... + log(n-1) + log(n) >= log(n/2) + ... + log(n/2) = n/2 * log(n/2)`
   - 取上限复杂度是 n(log n)
4. 整体时间复杂度是 O(n log n) + O(n) ==> O(nlog n)
